using System;
using System.Collections.Generic;
using System.IO;
using System.Text.Json;
using Microsoft.Extensions.Logging;
using PA193_Project.CommandLine;
using PA193_Project.Entities;
using PA193_Project.Modules;
using PA193_Project.Services;

namespace PA193_Project
{
    class EntryPoint
    {
        private readonly IParserService _parserService;
        private readonly ILogger<EntryPoint> _logger;

        public EntryPoint(IParserService parserService, ILogger<EntryPoint> logger)
        {
            this._parserService = parserService;
            this._logger = logger;
        }

        public void PrintFile(string json, string filename,string dir="")
        {
            dir = dir is null ? "" : dir;
            json = json.Replace("\u002B", "+");
            try
            {
                if (dir != "") Directory.CreateDirectory(dir);
                using (StreamWriter writer = new StreamWriter(Path.Combine(dir, filename + ".json")))
                {

                    writer.Write(json);
                }
            }
            catch (IOException e)
            {
                Console.WriteLine(e.Message);
            }
            
        }

        public void Run(String[] args)
        {
            // Set up global exception handler
            AppDomain.CurrentDomain.UnhandledException += UnhandledExceptionTrap;

            // Set up CLI options
            CommandLineOptions commandLineOptions = new CommandLineOptions();
            commandLineOptions.AddOption(new CommandLineOption("h", CommandLineOptionType.Switch, "Print this help"));
            commandLineOptions.AddOption(new CommandLineOption("help", CommandLineOptionType.Switch, ""));
            commandLineOptions.AddOption(new CommandLineOption("output", CommandLineOptionType.Option, "Output directory (will be created if doesn't exist)"));
            commandLineOptions.AddOption(new CommandLineOption("title", CommandLineOptionType.Switch, "Pretty print title"));
            commandLineOptions.AddOption(new CommandLineOption("toc", CommandLineOptionType.Switch, "Pretty print ToC"));
            commandLineOptions.AddOption(new CommandLineOption("versions", CommandLineOptionType.Switch, "Pretty print versions"));
            commandLineOptions.AddOption(new CommandLineOption("arg", CommandLineOptionType.Argument, "A text file of the certificate generated by pdftotext"));

            try
            {
                ParsedOptions parseResults = commandLineOptions.Parse(args);

                if (parseResults.IsEmpty()) { Console.WriteLine(commandLineOptions.GetHelp()); Environment.Exit(0); }

                string output = parseResults.Get<string>("output");
                _logger.LogDebug($"Output: {output}");

                bool help = parseResults.Get<bool>("h") || parseResults.Get<bool>("help");

                if (help) { Console.WriteLine(commandLineOptions.GetHelp()); Environment.Exit(0); }

                List<string> filepaths = parseResults.Get<List<string>>("arg");
                if (filepaths == null)
                {
                    Console.WriteLine(commandLineOptions.GetHelp());
                    Environment.Exit(1);
                }

                _parserService.RegisterModule(new HeaderFooterModule());
                _parserService.RegisterModule(new TitleModule());
                _parserService.RegisterModule(new TOCModule());
                _parserService.RegisterModule(new VersionsModule());

                foreach(var filepath in filepaths)
                {
                    _logger.LogDebug($"Filepath: {filepath}");

                    Document document = new Document
                    {
                        Filepath = filepath
                    };

                    _logger.LogDebug($"Generated {document.Indices.Count} indices");

                    var results = _parserService.Parse(document);

                    JsonSerializerOptions serializerOptions = new JsonSerializerOptions
                    {
                        IgnoreNullValues = false,
                    };

                    bool titleSwitch = parseResults.Get<bool>("title");
                    bool tocSwitch = parseResults.Get<bool>("toc");
                    bool versionsSwitch = parseResults.Get<bool>("versions");

                    if (output != null && output.Length > 0)
                        PrintFile(JsonSerializer.Serialize(results, serializerOptions), Path.GetFileNameWithoutExtension(filepath), output);
                    else if (!(titleSwitch || tocSwitch || versionsSwitch))
                        Console.WriteLine(JsonSerializer.Serialize(results, serializerOptions));

                    if (titleSwitch) { Console.WriteLine("Title:"); Console.WriteLine(results.title); }
                    if (tocSwitch)
                    {
                        Console.WriteLine("Table of contents:");
                        foreach (var entry in results.table_of_contents)
                            Console.WriteLine(entry[0] + " " + entry[1] + ", " + entry[2]);
                    }
                    if (versionsSwitch)
                    {
                        Console.WriteLine("Versions:");
                        foreach (var k in results.versions.Keys)
                        {
                            Console.Write(k + ": [");
                            List<string> versions = new List<string>();
                            foreach (var v in results.versions[k])
                            {
                                versions.Add(v);
                            }
                            Console.Write((String.Join(", ", versions)));
                            Console.WriteLine("]");
                        }
                    }
                }
            }

            catch (CommandLineArgumentException ex)
            {
                Console.WriteLine(ex.Message);
                Console.WriteLine(commandLineOptions.GetHelp());
            }
        }

        private void UnhandledExceptionTrap(object sender, UnhandledExceptionEventArgs unhandledExceptionEventArgs)
        {
            _logger.LogError(unhandledExceptionEventArgs.ExceptionObject.ToString());
            Environment.Exit(1);
        }
    }
}
